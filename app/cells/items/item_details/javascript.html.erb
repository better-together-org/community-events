<%= render_cell "theme_management", :javascript %>

<script type="text/javascript">

function showShortDescriptionDiv(el) {
    target = jQuery(el).closest(".form-horizontal").find('#short-versions-div');
    if (target.is(":visible")) {
        target.hide();
    } else {
        target.show();
    }
};

function set_theme(mdl, arg) {
    if (mdl) {
        var el = $("[name='theme_name_ids']");
        var data = el.select2('data');
        data.push({'id' : mdl.id, 'text' : mdl.get('name')});
        el.select2('data',data);
        el.select2('close');
    }
};

function toggleItemExtras(el) {
    if (!jQuery('input[name="is_break"]').is(":checked")){
        $extras = jQuery("#programme-item-extras");
        $el = jQuery(el);
        if ($extras.length > 0){
            $extras.toggle();
            if ($extras.is(":visible")){
                $el.removeClass("fa-plus-square");
                $el.addClass("fa-minus-square");
            } else {
                $el.removeClass("fa-minus-square");
                $el.addClass("fa-plus-square");
            }
        }
    }
};

ItemApp = new Backbone.Marionette.Application();

ItemApp.ItemManagement = (function(Backbone){
    var eventAggregator = AppUtils.eventAggregator;
    var selectCallbacks = $.Callbacks();
    var current_item = null;

    Picture = Backbone.RelationalModel.extend({
        schema : {
            picture : { 
                type : 'CloudImage', 
                title : 'Image',
                validators: [{
                    type: 'required',
                    message: '<%= j t("you-have-not-uploaded-an-image").html_safe %>'   
                }],
                cl_args : {
                          client_allowed_formats: ["png","gif","jpeg","jpg"],
                          max_file_size: (4.5 * 1024 * 1024), // 4.5Mb
                          button_caption: '<%= I18n.t("upload-image") %>'
                }
            }
        },
        urlRoot : "<%= baseUri + '/external_images/ProgrammeItem' %>",
        cropping_aspect_ratio : function() {
            var card_size = this.get('use');
            if (card_size == 'mediumcard') {
                return 1;
            } else if (card_size == 'largecard') {
                return 736/264;
            }
            return null;
        }
    });
    PictureCollection = Backbone.Collection.extend({
        model : Picture
    });

    /*
     * 
     */
    var minItemDuration = 1;
    ProgramItem = Backbone.RelationalModel.extend({
        schema : {
            title       : { type : 'Text', title : '<%= t "title" %>', validators: ['required'], editorClass: 'mandatory-field' },
            theme_name_ids  : { type : 'DependentSelect2', title : '<%= t "themes" %>', fieldClass : 'item-theme',
                                editorAttrs : { placeholder : '<%= t "select-a-theme-for-this-item" %>' },
                                dependsOn : 'is_break', dependentValues : ['false'],
                                        config : {
                                            multiple: true,
                                            initSelection : function(element,callback) {
                                                var vals = element.val();
                                                if (vals && current_item) {
                                                    res = [];
                                                    cats = current_item.get("theme_names");
                                                    _.each(cats, function(item) {
                                                        res.push( {'id' : item.id, 'text' : item.name} );
                                                    });
                                                    callback(res);
                                                }
                                            },
                                            formatSelection : function(obj, container) {
                                                return obj.text;
                                            },
                                            formatNoMatches : function(term) {
                                                return '<%= t "no-matches-found" %> <a href="/" onclick="ThemeApp.Mgmt.createNewTheme(\'' + escape(term) + '\', set_theme, \'item-theme\');"><%= t "create-theme" %> <b>' + term + '</b></a>'
                                            },
                                            ajax : {
                                                url : "<%= baseUri %>/theme_names",
                                                data : function(term, page) {
                                                    return { 'search' : term };
                                                },
                                                results : function(_data, page, query) {
                                                    res = [];
                                                    _.each(_data.rows, function(item) {
                                                        res.push( {'id' : item.id, 'text' : item.name} );
                                                    });
                                                    var data = {
                                                        results: res
                                                    };
                                                    return data;
                                                }
                                            }
                                        }
                                    },
            short_title : { type : 'Text', title : '<%= t "short-title" %>' },
            precis : { type : 'Html', title : '<%= t "item-description" %>', editorAttrs: { rows : 2, cols : 60 } },
            short_precis : { type : 'Html', title : '<%= t "short-item-description" %>', editorAttrs: { rows : 2, cols : 60 } },
            is_break    : { type : 'Checkbox', title : '<%= t "item-is-break" %>' },
            room_id : { 
                type : 'Select2',
                title : '<%= t "item-room" %>', 
                editorClass : 'item-form-element',
                validators: [
                    function check_for_time(value, formValues) {
                        var parent_err = {
                            type: "room_id",
                            message: '<%= t "child-item-can-not-be-assigned-to-room" %>'
                        };
                        if (formValues.room_id != "" && formValues.parent_id != "") {
                            $(this.$el).parent().parent().find('#room-error').html(parent_err.message);
                            return parent_err;
                        };
                        var err = {
                            type: "room_id",
                            message: '<%= t "time-required-when-you-set-a-room" %>'
                        };
                        if (formValues.room_id != "" && formValues.start_time == "" && !formValues.is_break) {
                            return err;
                        };
                    }
                ],
                config : {
                    placeholder : '<%= t('none') %>',
                    allowClear : true,
                    width : 'resolve',
                    dropdownAutoWidth : true,
                    multiple: false,
                    initSelection : function(element,callback) {
                        if (current_item) {
                            var roomId = current_item.get('room_id');
                            var roomName = current_item.get('room');
                            if (roomId && roomName && roomName.length > 0) {
                                callback(
                                    {
                                        id : roomId, 
                                        text : roomName
                                    }
                                );
                            }
                        }
                    },
                    formatSelection : function(obj, container) {
                        return obj.text;
                    },
                    formatResults : function(obj, container) {
                        return obj.text;
                    },
                    ajax : {
                        url : "<%= baseUri %>/rooms/for_select2", 
                        data : function(term, page) {
                            return { 'search' : term };
                        },
                        results : function(_data, page, query) {
                            var data = {
                                results: _data
                            };
                            return data;
                        }
                    }
                }
             },
            start_time : { type : 'Datetime', title : '<%= t "item-start-time" %>',
                editorClass : 'item-form-element',
                tz_offset : <%= Time.zone.parse(@start_date.start_date.to_s).utc_offset/60 %>,
                defaultDate: "<%= Time.zone.parse((@start_date.start_date + 8.hours).to_s).strftime('%m/%d/%Y %H:%M:%S') %>",
                picker : {
                    locale : "<%= I18n.locale %>",
                    stepping : minItemDuration,
                    format : "DD MMM YYYY, HH:mm",
                    useCurrent: false,
                    minDate : "<%= Time.zone.parse(@start_date.start_date.to_s).strftime('%m/%d/%Y') %>",
                    maxDate : "<%= (Time.zone.parse((@start_date.start_date + @start_date.number_of_days.days - 2.minutes).to_s)).strftime('%m/%d/%Y %H:%M:%S') %>",
                    sideBySide : true
                },
                validators: [
                    function check_for_room(value, formValues) {
                        var err = {
                            type: "start_time",
                            message: '<%= t "room-required-when-you-set-a-time" %>'
                        };
                        if (formValues.room_id == "" && formValues.start_time != "" && !formValues.is_break && formValues.parent_id == "") {
                            return err;
                        };
                    },
                    function check_end_time(value, formValues) {
                        var err = {
                            type: "mismatched_times",
                            message: '<%= t("start-time-must-be-less-than-end-time") %>'
                        };

                        fields = this.form.fields;
                        if (this.picker && fields.end_time.editor.picker){
                            startTime = this.picker.data("DateTimePicker").date();
                            endTime = fields.end_time.editor.picker.data("DateTimePicker").date();

                            if (startTime && endTime) {
                                diff = moment.duration(startTime.diff(endTime)).asMinutes();

                                if (diff >= 0) {
                                    return err;
                                };
                            };
                        };
                    },
                    function check_within_parent_time(value, formValues) {
                        var err = {
                            type: "parent_time",
                            message: '<%= t("start-time-cant-be-less-than-parent-time") %>'
                        };

                        fields = this.form.fields;
                        parent = fields.parent_id.editor.$el.select2("data");

                        if (
                            this.picker 
                            && parent && parent.id != null 
                            && parent.start_time_str && parent.start_time_str.length > 0
                        ){
                            startTime = this.picker.data("DateTimePicker").date();
                            pStart = moment(parent.start_time_str, "MM/DD/YYYY, HH:mm:SS");

                            if (startTime && pStart) {
                                diff = moment.duration(startTime.diff(pStart)).asMinutes();

                                if (diff < 0) {
                                    return err;
                                };
                            };
                        };
                    },
                ],
                callback: function(val, editor, obj) {
                    if (val) {
                        obj.picker.data("DateTimePicker").clear();
                        obj.form.fields['room_id'].setValue("");
                    }
                },
                changeFn : function(e) {
                    // console.log("start time changed");
                    // console.log(this);
                    // console.log(e);
                    fields = this.form.fields;
                    
                    if (this.picker && fields.end_time.editor.picker) {
                        // If both the start and end time fields have been initialized
                        startTime = this.picker.data("DateTimePicker").date();
                        endTime = fields.end_time.editor.picker.data("DateTimePicker").date();
                        // console.log(startTime);
                        if (startTime && endTime) {
                            // If both the start and end times are not empty
                            parent = fields.parent_id.editor.$el.select2("data"); // Parent object or null if not selected
                            withinParent = true;

                            if (parent && parent.id != null && parent.start_time_str && parent.start_time_str.length > 0) {
                                // If parent item is set, the end time should not change when changing the start time. 
                                // Changes in the start time should set the offset to the difference between the parent start time and the new start time.
                                
                                pStart = moment(parent.start_time_str, "MM/DD/YYYY, HH:mm:SS"); // Parent Start Time
                                pOffset = moment.duration(startTime.diff(pStart)).asMinutes(); // Parent start time offset
                                endDiff = moment.duration(endTime.diff(startTime)).asMinutes(); // Minutes between item's start and end times

                                if (pOffset < 0) {
                                    withinParent = false; // If calculated offset is less than 0, the item time is outside the parent range
                                };

                                if (withinParent) { 
                                    // If the start time is within the parent time range
                                    if (endDiff >= minItemDuration){ 
                                        // If the difference between the new start time and the end time is at least 5 minutes, set the start_offset field to the calculated offset value
                                        fields.start_offset.editor.$el.val(pOffset);
                                        fields.start_offset.editor.$el.trigger("change");
                                    } else { 
                                        // If the new start time will be greater than the end time, set the start date to minItemDuration mins less than the end time and cancel any further start time increases. 5 minutes is the min duration.
                                        newStart = endTime.subtract(minItemDuration, "minutes");
                                        this.picker.data("DateTimePicker").date(newStart);

                                        this.picker.effect("shake", { 
                                            times : 1,
                                            distance : 5
                                        }, 200);

                                        fields.duration.editor.$el.effect("shake", { 
                                            times : 1,
                                            distance : 5
                                        }, 200);
                                    };
                                } else { 
                                    // If item time is not within parent's time range, cancel the time change and alert the user by shaking the time and parent fields. This limits the start time to the parent's start time
                                    this.picker.data("DateTimePicker").date(pStart);

                                    this.picker.effect("shake", { 
                                        times : 1,
                                        distance : 5
                                    }, 200);

                                    fields.parent_id.editor.$el.siblings(".select2-container").effect("shake", { 
                                        times : 1,
                                        distance : 5
                                    }, 200);
                                };
                            } else {
                                // If a parent item is not selected, changes in the start time should set the end time to the new start_time  + the duration
                                fields.start_offset.editor.$el.val(null); // Clear the start_offset field

                                diff = moment.duration(endTime.diff(startTime)).asMinutes();
                                duration = fields.duration.editor.$el.val();
                                endMax = fields.end_time.editor.picker.data("DateTimePicker").maxDate().add(1, "seconds");
                                endDiff = moment.duration(endMax.diff(endTime)).asMinutes(); // Minutes between the current end time and the max end time
                                newEnd = startTime.clone().add(duration, "minutes"); // Potential new end time given the changed start time and duration
                                newEndDiff = moment.duration(endMax.diff(newEnd)).asMinutes(); // Minutes between the potential new end time and the max end time

                                if (newEndDiff >= minItemDuration){
                                    // If the difference between the potential new end time will not exceed the max end time
                                    if (endDiff >= minItemDuration && duration >= minItemDuration) {
                                        // If the new end time will not exceed the max end date, set the end date to the new value
                                        // 
                                        fields.end_time.editor.picker.data("DateTimePicker").date(newEnd);
                                        fields.duration.editor.$el.val(diff);

                                        if (newEndDiff > minItemDuration){
                                            if (!fields.end_time.editor.picker.find("input").attr('style')) {
                                                fields.end_time.editor.picker.find("input").effect("highlight", 800);
                                            };
                                        };
                                    } else {
                                        // If the new end time will exceed the max end time, reduce the duration
                                        fields.duration.editor.$el.val(diff);
                                        if (!fields.duration.editor.$el.attr('style')) {
                                            fields.duration.editor.$el.effect("highlight", 800);
                                        };
                                    };
                                } else {
                                    // If the new end time will exceed the max end time
                                    if (diff > 0){
                                        // If the new start time is not the same as the current end time, reduce the duration
                                        fields.duration.editor.$el.val(diff);
                                        if (!fields.duration.editor.$el.attr('style')) {
                                            fields.duration.editor.$el.effect("highlight", 800);
                                        };
                                    } else {
                                        // if the new start time is the same as the current end time, 
                                        this.picker.data("DateTimePicker").date(startTime.clone().subtract(duration, "minutes"));
                                        this.picker.effect("shake", { 
                                            times : 1,
                                            distance : 5
                                        }, 200);
                                    };
                                };
                                
                            };
                        } else if (startTime && endTime == null) {
                            // If the start time is present but the end time is empty, set the end time to the start time plus the duration
                            duration = fields.duration.editor.$el.val();
                            end = startTime.clone().add(duration, "minutes");
                            fields.end_time.editor.picker.data("DateTimePicker").date(end);
                            if (!fields.end_time.editor.picker.find("input").attr('style')) {
                                fields.end_time.editor.picker.find("input").effect("highlight", 800);    
                            }
                        } else if (startTime == null) {
                            fields.end_time.editor.picker.data("DateTimePicker").date(null);
                        };
                    };

                }
            },
            end_time : { 
                type : 'Datetime', 
                title : '<%= t "item-end-time" %>',
                editorClass : 'item-form-element',
                tz_offset : <%= Time.zone.parse(@start_date.start_date.to_s).utc_offset/60 %>,
                picker : {
                    locale : "<%= I18n.locale %>",
                    stepping : minItemDuration,
                    format : "DD MMM YYYY, HH:mm",
                    useCurrent: false,
                    minDate : "<%= Time.zone.parse((@start_date.start_date + 1.minutes).to_s).strftime('%m/%d/%Y') %>",
                    maxDate : "<%= (Time.zone.parse((@start_date.start_date + @start_date.number_of_days.days - 1.seconds).to_s)).strftime('%m/%d/%Y %H:%M:%S') %>",
                    sideBySide : true
                },
                validators: [
                    function check_start_time(value, formValues) {
                        var err = {
                            type: "mismatched_times",
                            message: '<%= t("end-time-must-be-greater-than-start-time") %>'
                        };

                        fields = this.form.fields;
                        if (this.picker && fields.start_time.editor.picker){
                            endTime = this.picker.data("DateTimePicker").date();
                            startTime = fields.start_time.editor.picker.data("DateTimePicker").date();

                            if (startTime && endTime) {
                                diff = moment.duration(endTime.diff(startTime)).asMinutes();

                                if (diff <= 0) {
                                    return err;
                                };
                            };

                        };
                    },
                    function check_within_parent_time(value, formValues) {
                        var err = {
                            type: "parent_time",
                            message: '<%= t("end-time-cant-be-greater-than-parent-time") %>'
                        };

                        fields = this.form.fields;
                        parent = fields.parent_id.editor.$el.select2("data");

                        // console.log(parent);

                        if (
                            this.picker 
                            && parent && parent.id != null 
                            && parent.end_time_str && parent.end_time_str.length > 0
                        ){
                            endTime = this.picker.data("DateTimePicker").date();
                            pEnd = moment(parent.end_time_str, "MM/DD/YYYY, HH:mm:SS");

                            if (endTime && pEnd) {
                                diff = moment.duration(endTime.diff(pEnd)).asMinutes();
                                // console.log(diff);

                                if (diff > 0) {
                                    return err;
                                };
                            };
                        };
                    },
                ],
                callback: function(val, editor, obj) {
                    if (val) {
                        obj.picker.data("DateTimePicker").clear();
                        obj.form.fields['room_id'].setValue("");
                    }
                },
                changeFn : function(e) {
                    // console.log("end time changed");
                    // console.log(this);
                    // console.log(e);
                    fields = this.form.fields;
                    var self = this;
                    
                    if (this.picker && fields.start_time.editor.picker) {
                        // If both start and end time fields are instantiated
                        endTime = this.picker.data("DateTimePicker").date();
                        startTime = fields.start_time.editor.picker.data("DateTimePicker").date();
                        // console.log(endTime);
                        parent = fields.parent_id.editor.$el.select2("data");

                        if (startTime && endTime) {
                            // If both start and end times are set
                            duration = fields.duration.editor.$el.val(); // Present duration
                            diff = moment.duration(endTime.diff(startTime)).asMinutes(); // Calculated new duration
                            withinParent = true; // Default value. 

                            if (parent && parent.id != null && parent.end_time_str && parent.end_time_str.length > 0){
                                // If parent item is set
                                pEnd = moment(parent.end_time_str, "MM/DD/YYYY, HH:mm:SS");
                                pDiff = moment.duration(pEnd.diff(endTime)).asMinutes(); // Minutes between parent end time and new end time

                                if (pDiff < 0) {
                                    // If new end time is greater than parent end time, set flag to false
                                    withinParent = false;
                                };
                            };

                            if (withinParent) {
                                // If parent not selected or item end time within parent time range
                                if (diff >= minItemDuration) {
                                    // If new duration is greater than or equal to the min duration, set the duration
                                    fields.duration.editor.$el.val(diff);
                                } else {
                                    // If new duration is negative or less than the min duration, cancel the new end date change by setting the end time to the start time plus the current duration, and shake the fields to indicate that the change failed
                                    end = startTime.clone().add(duration, "minutes");
                                    this.picker.data("DateTimePicker").date(end);

                                    this.picker.effect("shake", { 
                                        times : 1,
                                        distance : 5
                                    }, 200);

                                    fields.duration.editor.$el.effect("shake", { 
                                        times : 1,
                                        distance : 5
                                    }, 200);
                                };
                            } else {
                                // If new end date is after parent end date, set the end date to the aprent end date and shake the fields to indicate that the change failed
                                this.picker.data("DateTimePicker").date(pEnd);

                                this.picker.effect("shake", { 
                                    times : 1,
                                    distance : 5
                                }, 200);

                                fields.parent_id.editor.$el.siblings(".select2-container").effect("shake", { 
                                    times : 1,
                                    distance : 5
                                }, 200);
                            };
                        };
                    };
                }
            },
            start_offset : {
                type : 'DependentNumber',
                title : '<%= t "item-start-offset" %>',
                help: '<%= t "item-start-offset-help" %>',
                dependsOn : 'parent_id', dependentValues : ['not_null'],
                validators: [
                    function check_within_parent(value, formValues) {
                        var err = {
                            type: "start_offset",
                            message: '<%= t "cant-be-less-than-zero" %>'
                        };

                        if (value < 0 ) {
                            return err;
                        }
                    }
                ],
                changeFn : function() {
                    // console.log(this);
                    form = this.form;
                    offset = this.$el.val();
                    parent = fields.parent_id.editor.$el.select2("data");
                    if (
                        form.fields.start_time.editor.picker 
                        && parent && parent.id != null 
                        && parent.start_time_str && parent.start_time_str.length > 0
                    ){
                        // If parent item selected and it has a valid start time string
                        pStart = moment(parent.start_time_str, "MM/DD/YYYY, HH:mm:SS");
                        endTime = form.fields.end_time.editor.picker.data("DateTimePicker").date();

                        newStart = pStart.clone().add(offset, "minutes"); // New start time is parent time plus offset value

                        // Set duration to difference between new start time and the end time
                        newDuration = moment.duration(endTime.diff(newStart)).asMinutes();
                        form.fields.duration.editor.$el.val(newDuration);
                        
                        // Set start time to new start time
                        form.fields.start_time.editor.picker.data("DateTimePicker").date(newStart); 
                    };
                }
            },
            duration : { 
                type : 'NumberWithChange', 
                title : '<%= t "item-duration" %>', 
                editorClass : 'item-form-element', 
                editorAttrs : {
                    step : 1
                },
                validators: [
                    'required',
                    function check_greater_than_zero(value, formValues) {
                        var err = {
                            type: "duration",
                            message: '<%= t "cant-be-less-than-zero" %>'
                        };

                        if (value < 0) {
                            return err;
                        }
                    }
                ],
                changeFn : function() {
                    // console.log(this);
                    fields = this.form.fields;
                    duration = this.$el.val();
                    if (duration >= minItemDuration && fields.end_time.editor.picker && fields.start_time.editor.picker){
                        // If duration is not less than 5 mins and start and end time fields initialized
                        startTime = fields.start_time.editor.picker.data("DateTimePicker").date();
                        endTime = fields.end_time.editor.picker.data("DateTimePicker").date();
                        
                        if (startTime){
                            // If start time is not empty, set end time to start time plus duration and highlight the field to indicate it was automatically changed
                            newEnd = startTime.clone().add(duration, "minutes");
                            maxEnd = fields.end_time.editor.picker.data("DateTimePicker").maxDate().add(1, "seconds");
                            maxEndDiff = moment.duration(maxEnd.diff(newEnd)).asMinutes();

                            if (maxEndDiff <= 0 && endTime) {
                                newStart = endTime.clone().subtract(duration, "minutes");
                                fields.start_time.editor.picker.data("DateTimePicker").date(newStart);
                                if (!fields.start_time.editor.picker.find("input").attr('style')) {
                                    fields.start_time.editor.picker.find("input").effect("highlight", 800);    
                                };
                            } else {
                                fields.end_time.editor.picker.data("DateTimePicker").date(newEnd);
                                if (!fields.end_time.editor.picker.find("input").attr('style')) {
                                    fields.end_time.editor.picker.find("input").effect("highlight", 800);
                                };
                            };

                            
                        };
                    } else { 
                        // If duration is less than 5 mins, set duration to 5 mins (the minimum) and shake field to indicate a failed change
                        this.$el.val(minItemDuration);
                        this.$el.effect("shake", { 
                            times : 1,
                            distance : 5
                        }, 200);
                    };
                } 
            },
            parent_id : {
                type : 'DependentSelect2', 
                dependsOn : 'is_break', dependentValues : ['false'],
                title : '<%= t "parent-item" %>',
                help: '<%= t "parent-item-help" %>',
                config : {
                    multiple: false,
                    initSelection : function(element,callback) {
                        if (current_item) {
                            var pitem = current_item.get('parent_val');
                            if (pitem) {
                                callback(
                                    {
                                        'id' : pitem.get('id'), 
                                        'text' : (pitem.get('title') + pitem.get('date_time_str')),
                                        start_time : pitem.get('start_time'),
                                        end_time : pitem.get('end_time'),
                                        start_time_str : pitem.get("start_time_str"),
                                        end_time_str : pitem.get("end_time_str")
                                    }
                                );
                            }
                        }
                    },
                    formatSelection : function(obj, container) {
                        return obj.text;
                    },
                    ajax : {
                        url : "<%= baseUri %>/programme_items/list/no_breaks", // get the list of programme items - using a search term ....
                        data : function(term, page) {
                            return { 'search' : term };
                        },
                        results : function(_data, page, query) {
                            res = [{'id' : null, 'text' : "(<%= t 'planner.core.messages.no-parent' %>)" }];
                            _.each(_data.rows, function(item) {
                                res.push( 
                                    {
                                        'id' : item.id, 
                                        'text' : (item.title + item.date_time_str),
                                        start_time : item.start_time,
                                        end_time : item.end_time,
                                        start_time_str : item.start_time_str,
                                        end_time_str : item.end_time_str,
                                    } 
                                );
                            });
                            var data = {
                                results: res
                            };
                            return data;
                        }
                    }
                },
                changeFn : function(e) {
                    // console.log(this);
                    // console.log(parent);
                    parent = this.$el.select2("data");
                    form = this.form;
                    $form = this.form.$el;

                    if (parent && parent.id != null) {
                        // If parent item selected, clear room info and set item times to parent times
                        // 
                        // Clear room and setup fields
                        $room = $form.find("[name='room_id']");
                        $room.val(null);
                        $form.find("[name='setup_type_id']").val(null);
                        $room.parents(".form-group").hide();

                        if (parent.start_time_str && parent.start_time_str.length > 0 && parent.end_time_str && parent.end_time_str.length > 0) {
                            $form.find("#item-times-row").show();
                            // If parent has valid date strings, set item times to parent time
                            var pStart = moment(parent.start_time_str);
                            var pEnd = moment(parent.end_time_str);

                            var pDiff = moment.duration(pEnd.diff(pStart)).asMinutes(); // parent duration
                            form.fields.duration.editor.$el.val(pDiff); // set duration first to avoid change conflicts

                            // Set start and end time to parent times
                            
                            form.fields.start_time.editor.picker.data("DateTimePicker").date(null);
                            form.fields.end_time.editor.picker.data("DateTimePicker").date(null);
                            form.fields.start_time.editor.picker.data("DateTimePicker").date(pStart);
                            form.fields.end_time.editor.picker.data("DateTimePicker").date(pEnd);
                            
                        } else {
                            form.fields.start_time.editor.picker.data("DateTimePicker").date(null);
                            form.fields.end_time.editor.picker.data("DateTimePicker").date(null);
                            form.fields.duration.editor.$el.val(60);
                            $form.find("#item-times-row").hide();

                        };
                    } else if (parent && parent.id == null){
                        // If parent item is cleared, show room and room setup fields and clear start_offset value
                        this.form.$el.find("[name='room_id']").parents(".form-group").show();
                        $form.find("#item-times-row").show();
                        form.fields.start_offset.editor.$el.val(null);
                    };
                }
            },
            item_notes : { type : 'DependentTextArea', 
                            dependsOn : 'is_break', dependentValues : ['false'], 
                            title : '<%= t "item-notes" %>', editorClass : 'item-form-element notes-text-area note-small', editorAttrs: { rows : 2, cols : 60 } },
            participant_notes : { type : 'DependentTextArea', editorClass : 'item-form-element notes-text-area note-small',
                        dependsOn : 'is_break', dependentValues : ['false'],
                        title : '<%= t "item-notes-for-participants" %>', editorAttrs: { rows : 2, cols : 60 } },
            format_id : { type : 'Select',
                        editorClass : 'item-form-element',
                        title : '<%= t "item-format" %>', options : <%= [[' ',' ']].concat(Format.all.to_a.collect {|s| {'val' => s.id, 'label' => s.name} }).to_json.html_safe %> },
            setup_type_id : { type : 'Select', editorClass : 'item-form-element',
                        title : '<%= t "item-setup" %>', options : <%= [[' ',' ']].concat(SetupType.all.to_a.collect {|s| {'val' => s.id, 'label' => s.name} }).to_json.html_safe %> },
            print : { type : 'Checkbox', title : '<%= t "item-print" %>',  editorClass : 'item-form-element', editorAttrs : {tabindex : "-1"} },
            minimum_people : { type : 'DependentNumber', editorClass : 'item-form-element',
                                dependsOn : 'is_break', dependentValues : ['false'],
                                editorAttrs : { placeholder : '<%= t "min" %>' },
                                title : '<%= t "item-min-participants" %>', validators: [
                                { type: 'regexp', message: '<%= t "planner.core.errors.must-be-a-positive-number" %>', regexp: /^[0-9]\d*$/ }
                            ] },
            maximum_people : { type : 'DependentNumber', editorClass : 'item-form-element',
                                dependsOn : 'is_break', dependentValues : ['false'],
                                editorAttrs : { placeholder : '<%= t "max" %>' },
                                title : '<%= t "item-max-participants" %>', validators: [
                                { type: 'regexp', message: '<%= t "planner.core.errors.must-be-a-positive-number" %>', regexp: /^[0-9]\d*$/ }
                            ] },
            audience_size  : { type : 'DependentNumber', editorClass : 'item-form-element',
                                dependsOn : 'is_break', dependentValues : ['false'],
                                title : '<%= t "item-estimated-audience-size" %>' },
            pub_reference_number : { type : 'DependentText', editorClass : 'item-form-element',
                                    dependsOn : 'is_break', dependentValues : ['false'],
                                    title : '<%= t "item-publication-reference" %>' },
            mobile_card_size    : { type : 'Select',  editorClass : 'item-form-element', editorAttrs : {tabindex : "-1"}, title : '<%= t "mobile-card-size" %>', 
                                options : [{ val: 1, label: '<%= (t "small-feminin") %>' },{ val: 5, label: '<%= (t "medium-feminin") %>' },{ val: 10, label: '<%= (t "large-feminin") %>' }] }
        },
        // Default values used when creating a new instance
        defaults: {
            "duration":  60,
            "minimum_people": 1,
            "maximum_people": 5,
            "print": true,
            "mobile_card_size" : 1,
            "is_break"  : false,
            "audience_size" : 0,
        },
        urlRoot : "<%= baseUri + '/programme_items' %>",
        relations : [{
            type           : Backbone.HasMany,
            key            : 'external_images',
            relatedModel   : 'Picture',
            collectionType : 'PictureCollection'
        }, {
            type           : Backbone.HasOne,
            key            : 'parent_val',
            relatedModel   : 'ParentItem'
        }]
    });
    
    ParentItem = Backbone.RelationalModel.extend({});
    
    //
    TagContext = Backbone.Model.extend({
    });
    TagContextCollection = Backbone.Collection.extend({
        model : TagContext
    });
    TagFilter = Backbone.Model.extend({
        // Context name & Tag name
        // no ids cause no sync with backend (how to avoid dups? - TODO)
    });
    TagFilterCollection = Backbone.Collection.extend({
        model : TagFilter
    });
    
    ThemeName = Backbone.Model.extend({});
    Themes = Backbone.Collection.extend({
        model : ThemeName,
        urlRoot : "<%= baseUri + '/theme_names' %>"
    });
    
    ThemeView = Marionette.ItemView.extend({});


    ItemImageView = Marionette.ItemView.extend({
        template : '#item-images-template',
        events : {
            "click .large-image-create-button"  : "create_large_image",
            "click .large-image-edit-button"    : "edit_large_image",
            "click .large-image-delete-button"  : "delete_large_image",
            "click .medium-image-create-button" : "create_medium_image",
            "click .medium-image-edit-button"   : "edit_medium_image",
            "click .medium-image-delete-button" : "delete_medium_image"
        },

        initialize : function() {
            this.listenTo(this.model, 'change', this.render);
            eventAggregator.on("refreshImagesList", this.render, this);

        },
        
        onBeforeClose : function() {
            eventAggregator.off("refreshImagesList", this.render);
        },

        create_large_image : function(event) {
            this.create_image("largecard","Create Large Image");
        },
        edit_large_image : function(event) {
            this.edit_image("largecard","Edit Large Image");
        },
        delete_large_image : function(event) {
            this.delete_image("largecard");
        },
        create_medium_image : function(event) {
            this.create_image("mediumcard","Create Medium Image");
        },
        edit_medium_image : function(event) {
            this.edit_image("mediumcard","Edit Medium Image");
        },
        delete_medium_image : function(event) {
            this.delete_image("mediumcard");
        },
        
        // TOOD - aspect ratio for model depending on use
        create_image : function(cardtype, title) {
            var model = this.model;
            var pic = new Picture({
                use: cardtype
            });
            var item_id = model.id;
            pic.url = "<%= baseUri + '/external_images/ProgrammeItem/' %>" + item_id + '/' + cardtype
            mdl = new AppUtils.ModelModal({
                        model : pic,
                        title : title,
                        modal_template : "#image-uploader-form-template",
                        refresh : function(mdl) {
                            model.fetch({async : false});
                        }
                    });
            mdl.render();
        },
        
        edit_image : function(cardtype, title) {
            var item_id = this.model.id;
            var model = this.model;
            var img = _.find(this.model.get('external_images').models, function(im) { return im.get('use') == cardtype });
            img.url = "<%= baseUri + '/external_images/ProgrammeItem/' %>" + item_id + '/' + cardtype
            mdl = new AppUtils.ModelModal({
                        model : img,
                        title : title,
                        modal_template : "#image-uploader-form-template",
                        refresh : function(mdl) {
                            // Need to refresh the model
                            model.fetch({
                                async : false,
                                success : function() {
                                    eventAggregator.trigger("refreshImagesList");
                                }
                            });
                        }
                    });
            mdl.render();
        },
        
        delete_image : function(cardtype) {
            var item_id = this.model.id;
            var model = this.model;
            var that = this;

            modal = new AppUtils.ConfirmModel({
                title : '<%= I18n.t "delete-confirmation" %> ',
                content : '<%= (I18n.t "confirm-that-you-really-want-to-delete").html_safe %>',
                continueAction : function() {
                    var img = _.find(model.get('external_images').models, function(im) { return im.get('use') == cardtype });
                    img.destroy({
                        url : "<%= baseUri + '/external_images/' %>" + img.id
                    });
                    that.render();
                },
                closeAction : function() {
                }
            });
            modal.render();
        }
    });

    /*
     * 
     */
    ItemTabLayout = Backbone.Marionette.Layout.extend({
        template : "#item-tab-layout-template",
        
        regions : {
            program_item    : "#program-item-tab",
            participants    : "#item-participants-tab",
            tags            : "#tags-tab",
            images          : "#item-images-tab"
        }
    });
    
    /*
     * 
     */
    var filters = null;
    var itemTabLayout = null;
    
    function syncModel() {
        this.fetch({async : false});
    };
    
    function clearDetails() {
        $('#selected-program-item').text("");
        
        if (itemTabLayout) {
            itemTabLayout.program_item.close();
            itemTabLayout.participants.close();
            itemTabLayout.tags.close();
            itemTabLayout.images.close();
        };

        Backbone.Relational.store.reset();

        eventAggregator.off("refreshTagList", syncModel);
        
        current_item = null;
    };
    
    function showDetails(id, filterTable=false) {
        var data = jQuery("#items").jqGrid('getRowData', id);
        $('#selected-program-item').html(data['item[title]']);

        var itemMdl = new ProgramItem;

        itemMdl.deferred = itemMdl.fetch({
            url : "<%= baseUri + '/programme_items/' %>" + id + '.json',
            success : function(response) {
                if (filterTable){
                    $('#selected-program-item').html(response.get('title'));
                    $('input[name="programme_items.title"]').val(response.get('title')).trigger('keydown');
                };
            },
            async: true,
        }).done(function() {
                <% unless @dont_render_participants %>
                TabUtils.createTabContent({
                    model : itemMdl,
                    template : '#program-participants-view-template',
                    region : itemTabLayout.participants,
                    id : id,
                    id_name : 'programme_item_id',
                    editTitle : "Edit Item",
                    updateCallback : function(mdl, response, opts) {
                                    // 1. we need to refresh the row in the table (or the current table)
                                    // and make sure that the row is selected
                                    // Also need to update the title above the tabs
                                    $("#items").jqGrid('setGridParam', {
                                        loadComplete: function(data) {
                                            // alert("dd");
                                            $("#items").jqGrid('setSelection', id, false); // when load is complete the selection is called...
                                            // load complete is called every time... only want it once, so remove it after it has been used...
                                            $(this).jqGrid('setGridParam', { loadComplete: function() {} });
                                        }
                                    });
                                    $("#items").trigger("reloadGrid");
                                },
                    events : {
                        'click .add-people-button' : function() {
                            model = itemMdl;
                            modal = new AppUtils.PanelModal({
                                title : "<%= escape_javascript(t 'add-people') %>",
                                url   : "<%= baseUri + '/panels/item_mgmt?prog_item=' %>" + itemMdl.id,
                                title : '<%= t "add-people" %>',
                                closeCheck : function() {
                                    var res = document.getElementById('modal-iframe').contentWindow.ItemApp.PeopleManagement.needsSaved();
                                    return res;
                                },
                                closeAction : function() {
                                    itemMdl.fetch();
                                }
                            });
                            modal.render();
                        }
                    }
                });
                <% end %>
                
                mdl = TabUtils.createTabContent({
                    model : itemMdl,
                    url : "<%= baseUri + '/programme_items/' %>" + id + '.json',
                    template : '#program-item-summary-view-template',
                    region : itemTabLayout.program_item,
                    id : id,
                    id_name : 'programme_item_id',
                });
                
                itemTabLayout.images.show(new ItemImageView({model : itemMdl}) );
                
                TabUtils.createTagListContent({
                    collectionType : TagContextCollection,
                    url : "<%= baseUri + '/tags/' %>" + id + "?class=ProgrammeItem",
                    tagUrl : "<%= baseUri + '/tags/' %>"+ id + "/add?class=ProgrammeItem",
                    template : "#tag-context-layout-template",
                    view_refresh_event : "tags:refresh",
                    region : itemTabLayout.tags,
                    addTitle : '<%= t "create-tag" %>',
                });
        
                //initialize the popovers
                $(function () {
                    $('.bpopover').popover({
                        html: true,
                        viewport: { selector: 'body', padding: 0 },
                        container: 'body',
                    })
                });
                
                $('[data-toggle="tooltip"]').tooltip();
                
                eventAggregator.on("refreshTagList", syncModel, itemMdl);
        
                selectCallbacks.fire({
                    id : id,
                    model : itemMdl
                });

            current_item = itemMdl;
        });

        return itemMdl;
    };

    // item-filters == id
    // TODO - add filter for items
    function create_theme_selector() {
        
        $('#theme-filters').select2({
            multiple: true,
            formatSelection : function(obj, container) {
                return obj.text;
            },
            ajax : {
                url : "<%= baseUri %>/theme_names",
                data : function(term, page) {
                    return { 'search' : term };
                },
                results : function(_data, page, query) {
                    res = [];
                    _.each(_data.rows, function(item) {
                        res.push( {'id' : item.id, 'text' : item.name} );
                    });
                    var data = {
                        results: res
                    };
                    return data;
                }
            }
        }).on("change", function(e) {
            filterThemes = e.val;
            ItemApp.ItemManagement.refreshTable();
        });      
    };
    
    var filterCol = null;
    var filterThemes = null;
    
    function cloneItem() {
        // Get the selected person and call the clone and refresh the table...
        if (current_item) {
            modal = new AppUtils.ConfirmModel({
                    content : '<%= j t("do-you-want-to-copy-programme-item").html_safe %> <b>' + current_item.get('title') + '</b>?<br><br>' + '<%= j t("program-item-copy-details").html_safe %>',
                    title : '<%= j t("copy-programme-item").html_safe %>',
                    continueAction : function() {
                        // TODO - send the request to the server for a copy
                        $.ajax({
                            url : "<%= baseUri + '/programme_items/clone/' %>" + current_item.id,
                            success : function() {
                                $("#items").trigger("reloadGrid");
                            }
                        })
                    },
                    closeAction : function() {
                    }
            });
            modal.render();
        }
    };

    return {
        
        ProgramItem : ProgramItem,

        cloneItem : cloneItem,
        
        addSelectCallback : function(func) {
            selectCallbacks.add(func);
        },
        
        showDetails : function(id, filterTable=false) {
            clearDetails();
            return showDetails(id, filterTable);
        },
        clearDetails : function() {
            clearDetails();
        },
        loadActions : function() {
            if (!($("#item-control-area .new-msg-label").length > 0)) {
                var $extraBtn = $("#item-control-area .extra-action-model-button");
                if ($extraBtn.length > 0) {
                    var $newLabel = $("<span></span>").attr({
                        class : "label label-success new-msg-label",
                        style : "display: inline-block; cursor: default; float: none;"
                    }).html(
                        $('<i class="fa fa-arrow-left" aria-hidden="true"></i> <%= t 'new' %>!')
                    );
                    $extraBtn.after($newLabel);
                };
            };
        },

        addFilter : function(context, name) {
            if (!filters) {
                filters = new TagFilterCollection();
            }
            
            if (!filterCol) {
                filterCol = TabUtils.createTabListContent({
                    collection : filters,
                    template : "#item-filters-template",
                    place : "#item-filters",
                    tagremove : function(context, name) { // force a refresh of the table etc
                        ItemApp.ItemManagement.refreshTable();
                    },
                    view_attributes : { "style" : "display : inline" }, // TODO - move the style to the style-sheet
                });
            }
            
            filters.add(
                new TagFilter({
                    context : context,
                    name : name
                })
            );
        },
                
        getTagQuery : function() {
            var tagQuery = "";
            
            // go through the filters are create the query for the tags ...
            if (filters) {
                // convert the filters into an associative array and then build the query...
                var filterArray = {}
                _.each(filters, function(el, index, list) {
                    var ctx = filters.at(index).get('context');
                    if (!filterArray[ctx]) {
                        filterArray[ctx] = filters.at(index).get('name');
                    } else {
                        filterArray[ctx] += ',' + filters.at(index).get('name');                    
                    };
                });
                var str = "";
                var index = 0;
                _.each(filterArray, function(val, key, list) {
                    if (index > 0) {
                        str += "&";
                    };
                    str += "context[" + index + "]=" + key + "&tags[" + index + "]=" + encodeURIComponent(val);
                    index += 1;
                });
                tagQuery = str;
            }
            
            if (filterThemes && filterThemes.length > 0) {
                var str = "";
                if (tagQuery.length > 0) {
                    str += "&"
                }
                str += "theme_ids=" + encodeURIComponent(filterThemes);
                tagQuery += str;
            }
            
            return tagQuery;
        },
        
        refreshTable : function() {
            // get the tags etc from the view and create the query
            var tagQuery = ItemApp.ItemManagement.getTagQuery();
            jQuery("#items").itemTable('tagQuery',{ 
                tagQuery : tagQuery
            });
        },
        
        init : function() {
            // The layout manager for the tabs
            itemTabLayout = new ItemTabLayout();
            itemTabLayout.render();
            $('#item-tabs').html(itemTabLayout.el);
            
            create_theme_selector();
            
            TabUtils.createTagCloudContent({
                collectionType : TagContextCollection,
                url : "<%= baseUri + '/tags?class=ProgrammeItem' %>",
                template : "#tag-cloud-context-layout-template",
                place : '#item-tag-cloud',
                collection_attributes : { "class" : "accordion", "id" : "item-tag-cloud-parent" },
                view_attributes : { "class" : "accordion-group" },
                tagselect : function(context, name) {
                    ItemApp.ItemManagement.addFilter(context, name);
                    ItemApp.ItemManagement.refreshTable();
                },
            });

            $('#programme-item-tabs').tabdrop({
                text : "..."
            });

        }
    };
    
})(Backbone);

jQuery(document).ready(function() {
    moment.locale("<%= I18n.locale %>");
    ItemApp.addInitializer(ItemApp.ItemManagement.init);
    ItemApp.start();
});

</script>

<% @extra_javascript.each do |extra| %>
    <%= render extra %>
<% end %>
